/*1. Дано натуральное число N (2<=N<=1000). Определите рекурсивно, является ли оно простым.
  2.Реализуйте быструю сортировку. Изучите, как она работает. Сравните скорость работы с сортировкой обменами.
  3.Вам дано поле размерами NхM (2<=N,M<=100). В каждой клетке поля находятся символы:
‘.’ - можно пройти;
‘#’ - нельзя пройти;
‘S’ - начальная клетка;
‘E’ - конечная клетка;
Напишите алгоритм, который определит минимальное количество шагов для перемещения из начальной клетки в конечную.
Если это сделать невозможно, выведите -1. Ходить во все соседние клетки, которые отмечены ‘.’ (в том числе и по диагонали).*/

#include <iostream>
#include <queue>

using std::cout;
using std::cin;
using std::endl;
using std::swap;
using std::queue;

// Рекурсивная функция проверки делителей
bool isPrime(int n, int d = 2) { // d - текущий делитель (начинаем с 2)
    if (n <= 2) return (n == 2); // 2 - простое, числа меньше - нет
    if (n % d == 0) return false; // нашли делитель - не простое
    if (d*d > n) return true; // делители закончились - простое
    return isPrime(n, d + 1); // проверяем следующий делитель
}

void num1() {
    int N;
    cout << "Введите N: ";
    cin >> N;
    cout << (isPrime(N) ? "Простое" : " Не простое") << endl;
}

// Функция для разделения массива (опорный элемент - последний)
int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // выбираем опорный элемент
    int i = low - 1; // индекс для элементов меньше опорного

    for (int j = low; j < high; j++) { // проходим по всем элементам
        if (arr[j] < pivot) { // если элемент меньше опорного
            i++; // увеличиваем индекс
            swap(arr[i], arr[j]); // меняем местами
        }
    }
    swap(arr[i + 1], arr[high]); // ставим опорный элемент на место
    return i + 1; // возвращаем индекс опорного
}

// Рекурсивная быстрая сортировка
void quickSort(int arr[], int low, int high) {
    if (low < high) { // пока есть что сортировать
        int pi = partition(arr, low, high); // разделяем массив
        quickSort(arr, low, pi - 1); // сортируем левую часть
        quickSort(arr, pi + 1, high); // сортируем правую часть
    }
}

// Пузырьковая сортировка
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) { 
                swap(arr[j], arr[j+1]);
            }
        }
    }
}

void num2() {
    int arr[] = {5, 1, 4, 2, 8};
    int n = sizeof(arr)/sizeof(arr[0]);
    
    quickSort(arr, 0, n-1);
    
    
    cout << "Отсортированный массив: ";
    for (int i = 0; i < n; i++) cout << arr[i] << " ";
}


// Структура для хранения координат и шагов
struct Point {
    int x, y, steps;
    Point(int _x, int _y, int _s) : x(_x), y(_y), steps(_s) {}
};

void num3() {
    int N, M;
    char grid[100][100]; // максимальный размер поля
    queue<Point> q; // очередь для BFS
    bool visited[100][100] = {false}; // посещенные клетки

    // Ввод данных
    cout << "Введите N и M: ";
    cin >> N >> M;
    cout << "Введите поле:\n";
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            cin >> grid[i][j];
            if (grid[i][j] == 'S') { // находим старт
                q.push(Point(i, j, 0)); // добавляем в очередь
                visited[i][j] = true; // отмечаем как посещенную
            }
        }
    }

    // Направления движения (8 соседних клеток)
    int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
    int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};

    // BFS
    while (!q.empty()) {
        Point p = q.front(); // берем первую точку из очереди
        q.pop();

        // Проверяем, не пришли ли в конец
        if (grid[p.x][p.y] == 'E') {
            cout << "Минимальных шагов: " << p.steps << endl;
        }

        // Проверяем все 8 направлений
        for (int i = 0; i < 8; i++) {
            int nx = p.x + dx[i]; // новая координата x
            int ny = p.y + dy[i]; // новая координата y

            // Проверка границ и доступности клетки
            if (nx >= 0 && ny >= 0 && nx < N && ny < M && 
                !visited[nx][ny] && grid[nx][ny] != '#') {
                visited[nx][ny] = true; // отмечаем посещенной
                q.push(Point(nx, ny, p.steps + 1)); // добавляем в очередь
            }
        }
    }

    cout << "-1" << endl; // если путь не найден
}

int main()
{
    num1();
    num2();
    num3();
}